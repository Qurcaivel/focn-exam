# 1. Инкапсуляция, туннелирование и фрагментация в компьютерных сетях (примеры)

20 вопрос теории

## Инкапсуляция

![image](./.assets/encapsulation_practice.png)

## Туннелирование

Примеры туннелирования

 - VPN (виртуальная частная сеть): Туннелирование используется для создания шифрованного туннеля через общедоступную сеть, что позволяет удаленным пользователям безопасно подключаться к корпоративным сетям.

 - HTTP/SSL туннели: Этот тип туннелирования позволяет зашифровать данные, передаваемые через протокол HTTP, с использованием протокола SSL, обеспечивающего безопасную передачу информации через Интернет.

 - Туннелирование IPv6 через IPv4: Этот вид туннелирования используется для передачи трафика IPv6 через сети, которые поддерживают только IPv4.

- SSH туннель: SSH (Secure Shell) туннель позволяет безопасно передавать данные между удаленными устройствами, обеспечивая шифрование и аутентификацию.

## Фрагментация

Например, если компьютер A отправляет большой IP-пакет размером 1500 байтов, а промежуточный маршрутизатор имеет ограничение MTU 1000 байтов, то этот пакет будет фрагментирован на два фрагмента: первый будет содержать 1000 байтов данных, а второй - оставшиеся 500. Эти фрагменты будут отправлены через сеть и повторно собраны на конечном узле.

# 2. Алгоритмы бит-стаффинга и байт-стаффинга (схемы и алгоритмы)

вопросы теории № 20-21

пошаговый алгоритм бит-стаффинга

1. Входные данные: последовательность битов
2. Начало
3. Инициализация счетчика битов C = 0
4. Пока не достигнут конец последовательности
5. Если текущий бит равен 1 увеличить счётчик С на 1
6. Если счётчик равен 5 вставить бит 0 в последовательность и сбросить счётчик
7. Увеличить индекс текущего бита
8. Конец

пошаговый алгоритм байт-стаффинга

1. Входные данные: последовательность байтов для передачи.
2. Начало
3. Проход по каждому байту в последовательности.
4. Если встречается определенная последовательность байтов, то вставить специальный управляющий байт перед этой последовательностью.
5. Продолжение прохода по всей последовательности байтов.
6. конец

# 3. Линейные коды (кодирование)

вопросы теории № 24-26

# 8. TCP (диаграммы и взаимодействия с детализацией до SYN, ACK, FIN, SN, AN, W и Data) slow start, >1 сегмента, потеря сегмента

![image](./.assets/slow_start_2+segment.jpg)

Медленный старт (slow start).

Идея заключается в том, что в начале передачи размер текущего окна передачи нужно увеличивать не «скачком», а плавно, пропорционально скорости получения подтверждений (не превышая размер предлагаемого окна).

Рекомендуемые формулы:

$$IW = 2 * SMSS, если SMSS > 2190 Bytes ,$$
$$IW = 3 * SMSS, если 2190 Bytes >= SMSS > 1095 Bytes ,$$
$$IW = 4 * SMSS, если SMSS <= 1095 Bytes ,$$

где $IW$ (initial window) - начальное значение текущего окна передачи:

$$cwnd += min (N, SMSS) ,$$

где $cwnd$ (congestion window) - текущее окно передачи (в данном случае,окно затора), N - количество подтвержденных байтов, $SMSS$ (sender MSS) - $MSS$ передатчика.

Потеря сегмента

![image](./.assets/segment_loss.png)

Ограничение ожидания во времени достигается за счет применения тайм-аута (time-out).

После передачи некоторого служебного или информационного пакета, требующего подтверждения, запускается таймер с обратным отсчетом. 

Если в течение заданного интервала времени соответствующая квитанция не приходит, то пакет считается утерянным и передается повторно (retransmission).

Если квитанция не приходит снова и снова, то после некоторого конечного количества попыток дальнейшая передача считается бесперспективной и прекращается.

Следует учитывать, что:

- теряться могут как информационные пакеты, так и квитанции и пакеты-запросы;
- если квитанция приходит позже наступления тайм-аута, то этот факт приравнивается к ее потере;
- оптимальное время ожидания квитанций, применительно к некоторой СПД, зависит от ее особенностей.